parameters:
- name: osPlatform
  type: string
  values: [windows, ubuntu, macOS]
- name: runtimeType
  type: string
  values: [dotnet, mono]
  default: dotnet
- name: buildPlatform
  type: string
  values: [x86, x64]
- name: frameworks
  type: object
- name: buildConfiguration
  type: string
  default: Release
- name: publishBuild
  type: boolean
  default: false
- name: publishRawTestResults
  type: boolean
  default: false

jobs:
- job: ${{parameters.osPlatform}}_${{parameters.runtimeType}}_${{parameters.buildPlatform}}
  displayName: ${{replace(format('{0} {1} {2}', parameters.osPlatform, replace(parameters.runtimeType, 'dotnet', ''), parameters.buildPlatform), '  ', ' ')}}

  pool:
    vmImage: ${{parameters.osPlatform}}-latest

  # "variables" is misleading here - these are actually constants.
  # These must be declared here, since templates don't allow combining a root jobs (or steps) section and a root variables section.
  variables:
    # Note: Azure Pipelines currently has an issue where if the test name is in the fully qualified name format "namespace.classname.methodname(args)",
    # it only shows "methodname" rather than the fully qualified name (something do with more than 2 periods in the test name).
    # Workaround is to use the format: "namespace.classname:methodname(args)" (note the colon)
    # Also, Azure Pipelines command line argument parser tends to treat single quotes within argument strings literally, so using double quotes instead.
    runSettingsArgs: "NUnit.DefaultTestNamePattern=\"{C}:{m}{a}\" RunConfiguration.TargetPlatform=${{parameters.buildPlatform}}"
    # Blame mode helps isolate tests that cause crashes (https://github.com/Microsoft/vstest-docs/blob/master/docs/extensions/blame-datacollector.md),
    # although it somewhat ironically also makes such unstable tests crash less often, and makes the test suite run slightly slower.
    blameArg: --blame

  steps:
  - checkout: self
    submodules: recursive

  # For each .NET Core (and .NET 5+) version, ensure corresponding `dotnet` is installed.
  # Relies on all .NET Core (and .NET 5+) framework having a dot in their TFM.
  # Assumes that .NET Standard is never used.
  # Also assumes that the last .NET Core version listed in frameworks has the highest version among the listed frameworks.
  - ${{ each framework in parameters.frameworks }}:
    - ${{ if contains(framework, '.') }}:
      - task: UseDotNet@2
        displayName: "Install latest .NET ${{replace(replace(framework, 'coreapp', 'Core '), 'net', '')}}"
        inputs:
          packageType: sdk
          version: ${{replace(replace(framework, 'coreapp', ''), 'net', '')}}.x
          installationPath: $(Agent.ToolsDirectory)/dotnet

  - task: DotNetCoreCLI@2
    displayName: 'Build'
    inputs:
      command: build # `dotnet build` implicitly runs `dotnet restore` as well
      projects: Harmony.sln
      arguments: "--configuration ${{parameters.buildConfiguration}}"

  # For some reason, if mono is installed, above solution restore/build fails when restoring nugets (doesn't fail when only building a project).
  # Since mono is only needed for running tests in 'mono' runtimeType mode, only install mono after the restore/build.
  - ${{ if eq(parameters.runtimeType, 'mono') }}:
    - bash: "choco install mono --yes --no-progress --${{parameters.buildPlatform}}"
      displayName: 'Install Mono'

  # 'dotnet' runtimeType means using `dotnet test`.
  - ${{ each framework in parameters.frameworks }}:
    - ${{ if eq(parameters.runtimeType, 'dotnet') }}:
      # dotnet usage notes:
      # - `dotnet test` does work for .NET Framework targets, but they still implicitly require mono on non-Windows.
      #   `dotnet test` for .NET Core targets do not require mono (.NET Core is cross-platform).
      # - `dotnet test HarmonyTests`, even with --framework net35, won't run .NET Framework 3.5 tests unless IsTestPlatform is explicitly set
      #   (since Microsoft.NET.Test.Sdk only sets IsTestProject property for net40+). HarmonyTests.csproj works around this by setting IsTestPlatform for net35.
      # - `dotnet test path/to/<tfm>/HarmonyTests.dll --framework <tfm>` does work, but there's currently a bug where inline runSettings don't work
      #   (this is apparently fixed in .NET 5.0+), requiring a runSettings file (which would need to be generated beforehand). So not doing this.
      # - Even with the above workaround for running .NET Framework 3.5 tests, there is no CLR 2.0 runtime (or mono equivalent) available to properly test it.
      #   Both `dotnet test path/to/net35/HarmonyTests.dll --framework net35` and `mono path/to/nunit3-console.exe path/to/net35/HarmonyTests.dll`
      #   run the tests in 'CLR 4.0 "compatibility mode"' (or the mono equivalent of this).
      - task: DotNetCoreCLI@2
        displayName: "Test ${{replace(framework, 'net35', 'net35 in CLR 4.0 \"compatibility mode\"')}}"
        condition: succeededOrFailed()
        inputs:
          command: test
          projects: HarmonyTests
          arguments: "--no-build --configuration ${{parameters.buildConfiguration}} --framework ${{framework}} --logger \"console;verbosity=normal\" $(blameArg) -- $(runSettingsArgs)"
          publishTestResults: true
          # .NET Framework on non-Windows implicitly always uses mono.
          ${{ if and(ne(parameters.osPlatform, 'windows'), not(contains(framework, '.'))) }}:
            testRunTitle: "${{framework}} (${{parameters.osPlatform}} mono ${{parameters.buildPlatform}})"
          ${{ if or(eq(parameters.osPlatform, 'windows'), contains(framework, '.')) }}: # currently no `else` construct in Azure Pipelines
            testRunTitle: "${{framework}} (${{parameters.osPlatform}} ${{parameters.buildPlatform}})"

    # 'mono' runtimeType is for running .NET Framework tests on Windows (non-Windows will always run .NET Framework tests on mono even via `dotnet test`).
    - ${{ if eq(parameters.runtimeType, 'mono') }}:
      # Following attempts to replicate the behavior of DotNetCoreCLI test with publishTestResults=true, the main difference being:
      # - the usage of mono + vstest.console (since mono + dotnet test doesn't work)
      # - the actual test publishing delegated to a followup PublishTestResults task
      # - additionally copies over test result files to $(Build.ArtifactStagingDirectory) for a followup PublishBuildArtifacts task
      - bash: |
          shopt -s failglob globstar
          set -x
          # Remove any existing test result files.
          for testResultFile in "$(Agent.TempDirectory)"/**/*.trx; do
            rm "$testResultFile"
            # If there are test attachments, they are in a directory with same name as trx file, excluding the .trx extension.
            testResultDir="${testResultFile%.trx}"
            if [ -e "$testResultDir" ]; then
              rm -r "$testResultDir"
            fi
          done
          # Execute the tests via mono + vstest.console.
          mono="$PROGRAMFILES${{replace(replace(parameters.buildPlatform, 'x64', ''), 'x86', ' (x86)')}}/Mono/bin/mono.exe"
          vstest="$(vswhere.exe -latest -property installationPath)/Common7/IDE/CommonExtensions/Microsoft/TestWindow/vstest.console.exe"
          "$mono" "$vstest" "HarmonyTests/bin/${{parameters.buildConfiguration}}/${{framework}}/HarmonyTests.dll" --Framework:${{framework}} --logger:trx --ResultsDirectory:"$(Agent.TempDirectory)" $(blameArg) -- $(runSettingsArgs)
        displayName: "Test ${{replace(framework, 'net35', 'net35 in CLR 4.0 \"compatibility mode\"')}}"
        condition: succeededOrFailed()

    - ${{ if eq(parameters.runtimeType, 'mono') }}:
      - task: PublishTestResults@2
        displayName: "Publish ${{framework}} test results"
        condition: succeededOrFailed()
        inputs:
          buildPlatform: ${{parameters.buildPlatform}}
          buildConfiguration: ${{parameters.buildConfiguration}}
          testResultsFormat: VSTest
          testResultsFiles: '**/*.trx'
          searchFolder: $(Agent.TempDirectory)
          testRunTitle: "${{framework}} (${{parameters.osPlatform}} mono ${{parameters.buildPlatform}})"

    - ${{ if parameters.publishRawTestResults }}:
      - bash: |
          shopt -s failglob
          set -x
          # Move over test results to build artifact staging directory for the followup PublishBuildArtifacts task.
          artifactDir="$(Build.ArtifactStagingDirectory)/${{framework}}"
          mkdir -p "$artifactDir"
          # The bash version on macOS doesn't support globstar, so using find command + read loop workaround instead.
          find "$(Agent.TempDirectory)" -name '*.trx' -print0 | while IFS= read -r -d '' testResultFile; do
            mv "$testResultFile" "$artifactDir"
            testResultDir="${testResultFile%.trx}"
            if [ -e "$testResultDir" ]; then
              mv "$testResultDir" "$artifactDir"
            fi
          done
        displayName: "Stage ${{framework}} raw test results for build artifact publishing"
        condition: succeededOrFailed()
        continueOnError: true

  - ${{ if parameters.publishRawTestResults }}:
    - publish: $(Build.ArtifactStagingDirectory)
      displayName: 'Publish all raw test results (TRX) as build artifact'
      condition: succeededOrFailed()
      artifact: "TRX (raw test results) for $(System.JobDisplayName)"

  - ${{ if parameters.publishBuild }}:
    # publish task doesn't support globbing, so have to find the file and output it as a variable. Yes, this is clunky.
    - bash: |
        shopt -s failglob
        # Expecting only one zip file, but this allows script to error if no such zip file is found.
        for buildZipFile in Harmony/bin/Harmony*.zip; do
          echo "##vso[task.setvariable variable=buildZipFile]$buildZipFile"
        done
      name: FindBuildArtifact
      displayName: "Find Harmony zip for build artifact publishing"
      condition: succeededOrFailed()

    - publish: $(buildZipFile)
      displayName: "Publish Harmony zip as build artifact"
      artifact: ${{parameters.buildConfiguration}}
